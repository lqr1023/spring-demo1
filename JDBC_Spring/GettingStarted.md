### Accessing data with MySQL  https://github.com/spring-guides/gs-accessing-data-mysql.git    
### 创建数据库   
创建名为db_example的数据库,并创建新用户,授权
```  
mysql> create database db_example; -- Create the new database
mysql> create user 'springuser'@'localhost' identified by 'ThePassword'; -- Creates the user
mysql> grant all on db_example.* to 'springuser'@'localhost'; -- Gives all the privileges to the new user on the newly created database  
```  
### 创建application.properties文件  
Spring Boot 默认使用数据库H2,如果你想使用其他的数据库必须配置连接属性  
src/main/resources/application.properties  
```  
spring.jpa.hibernate.ddl-auto=create
spring.datasource.url=jdbc:mysql://localhost:3306/db_example
spring.datasource.username=springuser
spring.datasource.password=ThePassword  
```  
在这里spring.jpa.hibernate.ddl-auto可以设置的属性有none, update, create, create-drop，更多解释可以查看Hibernate的官方文档  
none:MySQL 默认值,不对数据库的结构进行操作  
update：Hibernate会根据实体类信息更改数据库   
create：每一次都重新创建数据库,但是关闭数据库时不会执行删除操作    
create-drop：创建数据库，当SessionFactory关闭时,同时删除数据库   
     
我们当前使用参数create因为目前还没有数据结构,第一次执行结束时,可以根据需求修改为update或者none.当你需要对数据库的结构进行操作时使用update参数.  
H2数据库和其他嵌入式数据库的默认值是create-drop，其他的数据库像MySQL的默认值就是none   
     
为了安全,当你的数据库在生产环境中建议使用none参数并且仅仅授予连接人 SELECT, UPDATE, INSERT, DELETE的数据操作权利,这个会在文末详细说明.   
### 创建实体类 src/main/java/hello/User.java  
``` 
package hello;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity // This tells Hibernate to make a table out of this class
public class User {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Integer id;

    private String name;

    private String email;

    ...
}
```  
Hibernate 会自动将这个实体类转为table  
### 创建仓库src/main/java/hello/UserRepository.java  
```  
package hello;

import org.springframework.data.repository.CrudRepository;

import hello.User;

// This will be AUTO IMPLEMENTED by Spring into a Bean called userRepository
// CRUD refers Create, Read, Update, Delete

public interface UserRepository extends CrudRepository<User, Integer> {

}   
```  
这个接口会被Spring自动继承,并创建同名的bean UserRepository   
### 创建一个新的控制类src/main/java/hello/MainController.java   
src/main/java/hello/MainController.java  
``` package hello;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import hello.User;
import hello.UserRepository;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path) 路径
public class MainController {
	@Autowired // This means to get the bean called userRepository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;

	@GetMapping(path="/add") // Map ONLY GET Requests
	public @ResponseBody String addNewUser (@RequestParam String name
			, @RequestParam String email) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		User n = new User();
		n.setName(name);
		n.setEmail(email);
		userRepository.save(n);
		return "Saved";
	}

	@GetMapping(path="/all")
	public @ResponseBody Iterable<User> getAllUsers() {
		// This returns a JSON or XML with the users
		return userRepository.findAll();
	}
}   
```    
上面的例子并没有明显区分GET和PUT，POST，因为@GetMapping是@RequestMapping（method=GET）的缩写,@RequestMapping 会对所有的Htto请求做映射,使用@RequestMapping(method=GET)或者其他的注解来缩小映射范围   
### 执行应用  spring boot 执行或者jar包运行  
### 做些安全上的改变  
当处于生存环境中时,可能会面临SQL注入风险.黑客可能注入DROP TABLE或者其他破坏性SQL命令,所以出于安全因素,在把应用拿给用户使用之前需要做些修改. 
   
取消所有权限   
``` 
mysql> revoke all on db_example.* from 'springuser'@'localhost';   
```
授权select, insert, delete, update
```
mysql> grant select, insert, delete, update on db_example.* to 'springuser'@'localhost'; 
```  
这会给予必要的权限,并且不会对数据表结构造成影响.   
修改src/main/resources/application.properties   
```  
spring.jpa.hibernate.ddl-auto=none   
```  
当你想对数据库做操作时,重新修改权限为update，然后再运行程序,或者使用其他的工具如Flyway or Liquibase.   








   



